#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# Filtrage collabortatif
#Coefficient de corrélation de Pearson
import numpy as np
import csv
import pickle
from math import sqrt
from math import fabs
from math import log

# Lire le fichier csv incomplet et le mettre dans un tableau
def lecture_csv():
    n = 100
    m = 1000

    fichier = './toy_incomplet.csv'
    donnees = np.zeros((n, m))
    i = 0
    with open(fichier, 'rb') as csvfile:
        spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
        for row in spamreader:
            for j in range(m):
                donnees[i, j] = row[j]
            i += 1
    return donnees


#tableau qui contient la moitie des notes seulement
donnees = lecture_csv()

#tableau intermediaire pour accelerer l'algorithme
tableauIntermediaire = np.zeros((100,1000))
listeMoyennes = []
tabSimilarite = np.zeros((100,100))

"""Recuperer une selection d'informations sur laquelle va se baser le systeme de filtrage
    La première consiste a recueillir de l'information
    La seconde consiste a batir une matrice contenant l'information.
    La troisieme à extraire a partir de cette matrice une liste de suggestions"""

"""Pour un filtrage base sur l’utilisateur, il faut definir une mesure de la similarite entre utilisateurs, et une
facon d’agreger les notes attribuees par les utilisateurs similaires.
    Chercher des utilisateurs qui ont les memes comportements avec l'utilisateur a qui l'on souhaite faire des recommandations
    Utiliser les notes des utilisateurs similaires pour calculer une liste de recommandations pour cet utilisateur."""


# Calcul de la similarité version utilisateur
def similariteFactoring(user1, user2):
    r = 0
    sommeUser1 = 0
    sommeUser2 = 0
    nombreItem = 0
    for i in range(np.shape(donnees)[1]):
        if donnees[user1][i] != -1 and donnees[user2][i] != -1:
            sommeUser1 += donnees[user1][i]
            sommeUser2 += donnees[user2][i]
            nombreItem = nombreItem + 1
    moyenneUser1 = sommeUser1 / nombreItem
    moyenneUser2 = sommeUser2 /nombreItem
    numerateur = 0
    norme1 = 0
    norme2 = 0
    if user1 != user2:
        for i in range(np.shape(donnees)[1]):
            if donnees[user1][i] != -1 and donnees[user2][i] != -1:
                numerateur += (donnees[user1][i] - moyenneUser1) * (donnees[user2][i] - moyenneUser2)
                norme1 += (donnees[user1][i] - moyenneUser1) ** 2
                norme2 += (donnees[user2][i] - moyenneUser2) ** 2
        r = numerateur / (sqrt(norme1) * sqrt(norme2))
    return r


def moyenneItems(user):
    somme = 0
    nombre = 0
    for i in range(np.shape(donnees)[1]):
        if donnees[user][i] != -1:
            somme += donnees[user][i]
            nombre += 1
    moyenne = somme/nombre
    return moyenne

def remplirListeMoyennes():
    for i in range(np.shape(donnees)[0]):
        listeMoyennes.append(moyenneItems(i))
    return listeMoyennes

def ponderationPremiere(user,item):
    num = 0
    den = 0
    for i in range(np.shape(donnees)[0]):
            if donnees[i][item] != -1:
                num += tabSimilarite[user][i] * (donnees[i][item] - listeMoyennes[i])
                den += fabs(tabSimilarite[user][i])
    return round(listeMoyennes[user] + num/den,2)

def remplirTabSimilarite():
    for i in range(np.shape(tabSimilarite)[0]):
        for j in range(np.shape(tabSimilarite)[0] ):
                tabSimilarite[i][j] = similariteFactoring(i,j)
                print tabSimilarite[i][j]
    return tabSimilarite
                
def ponderationSeconde(user,item):
    num = 0
    den = 0
    for i in range(np.shape(donnees)[0]):
        if donnees[i,item] != -1:       
            num += donnees[user][i] * similariteFactoring(user,i)
            den += fabs(similariteFactoring(user,i))
    return num/den


""" autre types de ponderation : weighted majority prediction and  imputation-boosted CF"""

def remplirTabInter():
    for i in range(np.shape(donnees)[0]):
        for j in range(np.shape(donnees)[1]):
            if donnees[i][j] == -1:
                tableauIntermediaire[i][j] = ponderationPremiere(i,j)
                print tableauIntermediaire[i][j]
    return tableauIntermediaire
                
                
def donneesCompletes():
    donneesCompletes = donnees
    for i in range(np.shape(donneesCompletes)[0]):
        for j in range(np.shape(donneesCompletes)[1]):
            if donneesCompletes[i][j] == -1:
                donneesCompletes[i][j] = tableauIntermediaire[i][j]
                print donneesCompletes[i][j]
    return donneesCompletes

#savoir si les items les plus aimes ou detestes sont plus note que les autres items
def frequence(item):
    ni = 0
    for i in range(np.shape(donnees)[0]):
        if donnees[i][item] != -1:
            ni += 1
    return log(100) /ni

""" Ceci a permit de construire le tableau de donnes estimees
listeMoyennes = remplirListeMoyennes()
tabSimilarite = remplirTabSimilarite()
remplirTabInter()   
donneesCompletes = donneesCompletes()
"""

#pickle pour enregistrer nos objets : serialisation
with open('PearsonUser', 'wb') as fichier:
    mon_pickler = pickle.Pickler(fichier)
    mon_pickler.dump(donneesCompletes)